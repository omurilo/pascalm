#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "types.h"
#include "symbol-table.h"
#include "tac.h"

int temp_count = 0;
int label_count = 0;

ExprResult generate_expr_tac(Expr *e) {
  ExprResult res = {NULL, NULL};

  if (e->type == EXPR_ARITH) {
    ExprResult left;
    ExprResult right = generate_expr_tac(e->arith.right);
    char *temp = new_temp();
    char op;
    char buffer[128];

    switch (e->arith.op) {
    case AOP_PLUS:
      op = '+';
      break;
    case AOP_MINUS:
      op = '-';
      break;
    case AOP_TIMES:
      op = '*';
      break;
    case AOP_DIVIDE:
      op = '/';
      break;
    case AOP_UMINUS:
      op = '-';
      break;
    default:
      op = '?';
      break;
    }

    if (e->arith.op == AOP_UMINUS) {
      snprintf(buffer, sizeof(buffer), "%s = -%s", temp, right.temp);
      res.code = left.code;
    } else {
      left = generate_expr_tac(e->arith.left);
      snprintf(buffer, sizeof(buffer), "%s = %s %c %s", temp, left.temp, op,
               right.temp);
      res.code = tac_append(left.code, right.code);
    }

    TAC *instr = tac_create(buffer);
    res.temp = temp;
    res.code = tac_append(res.code, instr);
    return res;
  }

  if (e->type == EXPR_LOGIC) {
    ExprResult left;
    ExprResult right = generate_expr_tac(e->logic.right);
    char *temp = new_temp();
    const char *op;
    char buffer[128];

    switch (e->logic.op) {
    case OP_GT:
      op = ">";
      break;
    case OP_GTE:
      op = ">=";
      break;
    case OP_LT:
      op = "<";
      break;
    case OP_LTE:
      op = "<=";
      break;
    case OP_EQUALS:
      op = "==";
      break;
    case OP_DIFF:
      op = "!=";
      break;
    case OP_OR:
      op = "||";
      break;
    case OP_AND:
      op = "&&";
      break;
    default:
      op = "?";
      break;
    }

    left = generate_expr_tac(e->logic.left);
    snprintf(buffer, sizeof(buffer), "%s = %s %s %s", temp, left.temp, op,
             right.temp);
    res.code = tac_append(left.code, right.code);

    TAC *instr = tac_create(buffer);
    res.temp = temp;
    res.code = tac_append(res.code, instr);
    return res;
  }

  if (e->type == EXPR_LITERAL) {
    char *temp = new_temp();
    char buffer[64];

    switch (e->literal.type) {
    case TYPE_INT:
      snprintf(buffer, sizeof(buffer), "%s = %d", temp, e->literal.data.i);
      break;
    case TYPE_REAL:
      snprintf(buffer, sizeof(buffer), "%s = %.2f", temp, e->literal.data.f);
      break;
    case TYPE_BOOL:
      snprintf(buffer, sizeof(buffer), "%s = %d", temp, e->literal.data.b);
      break;
    case TYPE_CHAR:
      snprintf(buffer, sizeof(buffer), "%s = %c", temp, e->literal.data.c);
      break;
    case TYPE_STRING:
      snprintf(buffer, sizeof(buffer), "%s = %s", temp, e->literal.data.s);
      break;
    }

    res.temp = temp;
    res.code = tac_create(buffer);
    return res;
  }

  if (e->type == EXPR_VAR) {
    res.temp = strdup(e->var_name);
    res.code = NULL;
    return res;
  }

  return res;
}

TAC *generate_stmt_tac(Stmt *s) {
  if (s->type == STMT_ATTRIB) {
    verify_assign_types(s);

    ExprResult rhs = generate_expr_tac(s->assign.expr);
    TAC *code = rhs.code;
    char buffer[128];
    snprintf(buffer, sizeof(buffer), "%s = %s", s->assign.var_name, rhs.temp);
    code = tac_append(code, tac_create(buffer));
    return code;
  }

  if (s->type == STMT_WHILE) {
    char *label_start = new_label();
    char *label_end = new_label();

    TAC *code = tac_create("%s:", label_start);
    ExprResult cond = generate_expr_tac(s->while_stmt.cond);
    code = tac_append(code, cond.code);

    char buffer[128];
    snprintf(buffer, sizeof(buffer), "ifFalse %s goto %s", cond.temp,
             label_end);
    code = tac_append(code, tac_create(buffer));

    TAC *body_code = generate_stmt_list_tac(s->while_stmt.body);
    code = tac_append(code, body_code);

    snprintf(buffer, sizeof(buffer), "goto %s", label_start);
    code = tac_append(code, tac_create(buffer));

    snprintf(buffer, sizeof(buffer), "%s:", label_end);
    code = tac_append(code, tac_create(buffer));

    return code;
  }

  if (s->type == STMT_IF) {
    ExprResult cond = generate_expr_tac(s->if_stmt.cond);
    char *label_else = new_label();
    char *label_end = new_label();

    char buffer[128];
    TAC *code = cond.code;
    snprintf(buffer, sizeof(buffer), "ifFalse %s goto %s", cond.temp,
             label_else);
    code = tac_append(code, tac_create(buffer));

    TAC *then_code = generate_stmt_list_tac(s->if_stmt.then_block);
    code = tac_append(code, then_code);

    snprintf(buffer, sizeof(buffer), "goto %s", label_end);
    code = tac_append(code, tac_create(buffer));

    snprintf(buffer, sizeof(buffer), "%s:", label_else);
    code = tac_append(code, tac_create(buffer));

    if (s->if_stmt.else_block) {
      TAC *else_code = generate_stmt_list_tac(s->if_stmt.else_block);
      code = tac_append(code, else_code);
    }

    snprintf(buffer, sizeof(buffer), "%s:", label_end);
    code = tac_append(code, tac_create(buffer));

    return code;
  }

  if (s->type == STMT_WRITE) {
    ExprResult val;
    if (s->write.var_name) {
      Expr *e = (Expr *)malloc(sizeof(Expr));
      e->type = EXPR_VAR;
      e->var_name = strdup(s->write.var_name);
      val = generate_expr_tac(e);
    } else {
      val = generate_expr_tac(s->write.expr);
    }
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "print %s", val.temp);
    TAC *code = val.code;
    code = tac_append(code, tac_create(buffer));

    return code;
  }

  if (s->type == STMT_READ) {
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "read %s", s->read.var_name);

    TAC *code = tac_create(buffer);

    return code;
  }

  return NULL;
}

TAC *generate_stmt_list_tac(StmtList *list) {
  TAC *code = NULL;
  while (list) {
    TAC *stmt_code = generate_stmt_tac(list->stmt);
    code = tac_append(code, stmt_code);
    list = list->next;
  }
  return code;
}

TAC *tac_create(const char *fmt, ...) {
  TAC *tac = (TAC *)malloc(sizeof(TAC));
  char buffer[256];

  va_list args;
  va_start(args, fmt);
  vsnprintf(buffer, sizeof(buffer), fmt, args);
  va_end(args);

  tac->code = strdup(buffer);
  tac->next = NULL;
  return tac;
}

TAC *tac_append(TAC *list, TAC *new_code) {
  if (!list)
    return new_code;
  TAC *curr = list;
  while (curr->next)
    curr = curr->next;
  curr->next = new_code;
  return list;
}

void tac_print(TAC *code) {
  while (code) {
    printf("%s\n", code->code);
    code = code->next;
  }
}

char *new_temp() {
  char buffer[16];
  snprintf(buffer, sizeof(buffer), "t%d", temp_count++);
  return strdup(buffer);
}

char *new_label() {
  char buf[20];
  sprintf(buf, "L%d", label_count++);
  return strdup(buf);
}

void verify_assign_types(Stmt *s) {
  int attrib_si = get_symbol_index(s->assign.var_name);
  char buffer[256];

  if (attrib_si == -1) {
    snprintf(
        buffer, sizeof(buffer),
        "Undefined declaration of identifier '%s' at line: %d and column: %d",
        s->assign.var_name, s->lineno, s->col);
    yyerror(buffer);
  }

  Value expr_value;

  if (s->assign.expr->type == EXPR_LOGIC) {
    expr_value = evaluate_logical_expr(s->assign.expr);
  } else if (s->assign.expr->type == EXPR_ARITH) {
    expr_value = evaluate_arithmetic_expr(s->assign.expr);
  } else if (s->assign.expr->type == EXPR_VAR ||
             s->assign.expr->type == EXPR_LITERAL) {
    expr_value = evaluate_factor_expr(s->assign.expr);
  }

  int val_type = expr_value.type;

  switch (symb_table[attrib_si].type) {
  case TYPE_INT:
    if (val_type != TYPE_INT) {
      snprintf(buffer, sizeof(buffer),
               "Semantic Error: Variable '%s' type mismatch at line: %d and "
               "column: %d",
               s->assign.var_name, s->lineno, s->col);
      yyerror(buffer);
    }
    break;
  case TYPE_BOOL:
    if (val_type != TYPE_BOOL) {
      snprintf(buffer, sizeof(buffer),
               "Semantic Error: Variable '%s' type mismatch at line: %d and "
               "column: %d",
               s->assign.var_name, s->lineno, s->col);
      yyerror(buffer);
    }
    break;
  case TYPE_CHAR:
    if (val_type != TYPE_CHAR) {
      snprintf(buffer, sizeof(buffer),
               "Semantic Error: Variable '%s' type mismatch at line: %d and "
               "column: %d",
               s->assign.var_name, s->lineno, s->col);
      yyerror(buffer);
    }
    break;
  case TYPE_REAL:
    if (val_type != TYPE_REAL && val_type != TYPE_INT) {
      snprintf(buffer, sizeof(buffer),
               "Semantic Error: Variable '%s' type mismatch at line: %d and "
               "column: %d",
               s->assign.var_name, s->lineno, s->col);
      yyerror(buffer);
    }
    break;
  default:
    break;
  }
}
